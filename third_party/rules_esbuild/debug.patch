diff --git a/esbuild/private/plugins/bazel-sandbox.js b/esbuild/private/plugins/bazel-sandbox.js
index 84f0921..81f31af 100644
--- a/esbuild/private/plugins/bazel-sandbox.js
+++ b/esbuild/private/plugins/bazel-sandbox.js
@@ -28,15 +28,24 @@ function bazelSandboxPlugin() {
           }
           otherOptions.pluginData.executedSandboxPlugin = true

+          if (importPath === 'minipass') {
+            console.error(`DEBUG NOAH BEGIN: \n\tIMPORTER ${otherOptions.importer}\n\tRESOLVEDIR ${otherOptions.resolveDir}\n\tIMPORT ${importPath}`)
+          }
+
           // Prevent us from loading different forms of a module (CJS vs ESM).
           if (pkgImport.test(importPath)) {
-            if (!moduleCache.has(importPath)) {
-              moduleCache.set(
-                importPath,
-                resolveInExecroot(build, importPath, otherOptions)
-              )
-            }
-            return await moduleCache.get(importPath)
+            // const isCached = !moduleCache.has(importPath)
+            // if (isCached) {
+            //   moduleCache.set(
+            //     importPath,
+            //     resolveInExecroot(build, importPath, otherOptions)
+            //   )
+            // }
+            // const res = await moduleCache.get(importPath)
+            // if (importPath === 'minipass' && isCached) {
+            //   console.error(`DEBUG NOAH RETURN CACHE: \n\tIMPORTER ${otherOptions.importer}\n\tRESOLVEDIR ${otherOptions.resolveDir}\n\tIMPORT ${importPath}\n\tRESOLVED ${res.path}`)
+            // }
+            // return res
           }
           return await resolveInExecroot(build, importPath, otherOptions)
         }
@@ -62,8 +71,29 @@ async function resolveInExecroot(build, importPath, otherOptions) {
     return result
   }

+  const res = correctImportPath(result, otherOptions, false)
+  if (importPath ==='minipass') {
+    console.error(`DEBUG NOAH RETURN RESOLVE: \n\tIMPORTER ${otherOptions.importer}\n\tRESOLVEDIR ${otherOptions.resolveDir}\n\tIMPORT ${importPath}\n\tRESOLVED ${res.path}`)
+  }
+  return res
+}
+
+function correctImportPath(result, otherOptions, firstEntry) {
   // If esbuild attempts to leave the execroot, map the path back into the execroot.
   if (!result.path.startsWith(execroot)) {
+    // A relative path that is marked as external. If it was not marked as external, it would error in the build.resolve call.
+    // We need to make it an absolute path from its importer and then re-attempt correcting it to be within the execroot.
+    if (result.path.startsWith("..")) {
+      const absPath = path.resolve(otherOptions.importer, result.path)
+      if (!!process.env.JS_BINARY__LOG_DEBUG) {
+        console.error(
+          `DEBUG: [bazel-sandbox] relative + external path found ${result.path}, making absolute relative to its importer ${otherOptions.importer} and then reattempting making it relative to the execroot (${execroot}): ${absPath}`
+        )
+      }
+      result.path = absPath
+      return correctImportPath(result, otherOptions, true)
+    }
+
     // If it tried to leave bazel-bin, error out completely.
     if (!result.path.includes(bindir)) {
       throw new Error(
